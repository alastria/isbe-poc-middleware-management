
name: 2) EKS AWS Deploy to EKS Cluster
description: Deploy the application to the EKS cluster from image ECR, using the helm deployment (in .helm folder)

on:
  workflow_dispatch:
    inputs:
      version_tag:
        description: 'Image tag to deploy (from ECR). If not provided, "latest" will be used'
        required: false
        type: string

env:
  IMAGE_TAG: "${{ github.event.inputs.version_tag || 'latest' }}"

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    # TODO: change to main or develop, or add other branches
    environment: "${{ github.ref_name == 'main' && 'main' || github.ref_name == 'develop' && 'develop' || 'develop'  }}"

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Check variables and secrets
      run: |
        echo "ğŸ”‘ DEPLOY status -> ${{ vars.DEPLOY }}"
        if [[ -z "${{ vars.DEPLOY }}" || "${{ vars.DEPLOY }}" != "true" ]]; then
          echo "âš ï¸ DEPLOY disabled, please set DEPLOY=true on Github in variables"
          echo "â­ï¸ Skipping deployment step."
          exit 1
        fi
        if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]]; then
          echo "ğŸ›‘ AWS_ACCESS_KEY_ID is not set in secrets"
          exit 1
        fi
        if [[ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]]; then
          echo "ğŸ›‘ AWS_SECRET_ACCESS_KEY is not set in secrets"
          exit 1
        fi
        if [[ -z "${{ vars.AWS_REGION }}" ]]; then
          echo "ğŸ›‘ AWS_REGION is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.APP_NAME }}" ]]; then
          echo "ğŸ›‘ APP_NAME is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.EKS_CLUSTER_NAME }}" ]]; then
          echo "ğŸ›‘ EKS_CLUSTER_NAME is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.EKS_NAMESPACE }}" ]]; then
          echo "ğŸ›‘ EKS_NAMESPACE is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.HOST_NAME }}" ]]; then
          echo "ğŸ›‘ HOST_NAME is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.ALLOWED_ORIGINS }}" ]]; then
          echo "ğŸ›‘ ALLOWED_ORIGINS is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.PUBLIC_BASE_URL }}" ]]; then
          echo "ğŸ›‘ PUBLIC_BASE_URL is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.AUTH_N_ENABLED }}" ]]; then
          echo "ğŸ›‘ AUTH_N_ENABLED is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.FAKE_ROLE }}" ]]; then
          echo "ğŸ›‘ FAKE_ROLE is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.FAKE_USER_ID }}" ]]; then
          echo "ğŸ›‘ FAKE_USER_ID is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.FAKE_COMPANY_ID }}" ]]; then
          echo "ğŸ›‘ FAKE_COMPANY_ID is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.KEYCLOAK_ISSUER }}" ]]; then
          echo "ğŸ›‘ KEYCLOAK_ISSUER is not set in variables"
          exit 1
        fi
        if [[ -z "${{ vars.KEYCLOAK_AUDIENCE }}" ]]; then
          echo "ğŸ›‘ KEYCLOAK_AUDIENCE is not set in variables"
          exit 1
        fi
        if [[ -z "${{ secrets.DATABASE_URL }}" ]]; then
          echo "ğŸ›‘ DATABASE_URL is not set in secrets"
          exit 1
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION }}
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} --name ${{ vars.EKS_CLUSTER_NAME }}

    - name: Deploy to EKS
      env:
        ECR_REPOSITORY: ${{ vars.APP_NAME }}
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ env.IMAGE_TAG }}
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_REGION: ${{ vars.AWS_REGION }}
        HOST_NAME: ${{ vars.HOST_NAME }}
        EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
        ALLOWED_ORIGINS: ${{ vars.ALLOWED_ORIGINS }}
        PUBLIC_BASE_URL: ${{ vars.PUBLIC_BASE_URL }}
        AUTH_N_ENABLED: ${{ vars.AUTH_N_ENABLED }}
        FAKE_ROLE: ${{ vars.FAKE_ROLE }}
        FAKE_USER_ID: ${{ vars.FAKE_USER_ID }}
        FAKE_COMPANY_ID: ${{ vars.FAKE_COMPANY_ID }}
        KEYCLOAK_ISSUER: ${{ vars.KEYCLOAK_ISSUER }}
        KEYCLOAK_AUDIENCE: ${{ vars.KEYCLOAK_AUDIENCE }}
        DATABASE_URL: ${{ secrets.DATABASE_URL }}

      run: |
        echo "ğŸ—ï¸ Environment: ${{ vars.ENVIRONMENT }}"
        echo "ğŸš€ Desplegando desde rama: ${{ github.ref_name }}"
        echo "ğŸ“¦ App name: ${{ vars.APP_NAME }}"
        echo "ğŸ·ï¸ Image tag: ${{ env.IMAGE_TAG }}"
        echo "ğŸ·ï¸ EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}"
        echo "ğŸ·ï¸ EKS_NAMESPACE: ${{ vars.EKS_NAMESPACE }}"
        echo "ğŸ·ï¸ ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}"
        echo "ğŸ·ï¸ ECR_REGISTRY: ${{ env.ECR_REGISTRY }}"

        echo " > Check existing image in ECR..."
        if ! aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=$IMAGE_TAG >/dev/null 2>&1; then
          echo "âŒ Image $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG does not exist in ECR. Aborting deployment."
          exit 1
        fi
        echo "ğŸ‘‰ğŸ» âœ… Image $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG "
        
        cd .helm

        # Install or Update Helm chart values with the correct image details
        echo " > Installing or Updating Helm chart with image details..."

        envsubst < values.yaml | helm template . --debug --values - 

        echo " > Checking if deployment exists... (for example: sh.helm.release.v1.${{ vars.APP_NAME }}.v1)"
        if kubectl -n ${{ vars.EKS_NAMESPACE }} get secrets | grep ${{ vars.APP_NAME }}.v; then 
          echo " > Deployment exists."
          echo " > Updating Helm chart values with image details..."
          envsubst < values.yaml | helm upgrade ${{ vars.APP_NAME }} . --namespace ${{ vars.EKS_NAMESPACE }} --create-namespace --values -
          # Force restart pods to pick up new environment variables from updated secrets/configmaps
          echo " > Restarting pods to pick up new environment variables..."
          kubectl -n ${{ vars.EKS_NAMESPACE }} rollout restart deployment ${{ vars.APP_NAME }}
        else
          echo " > Deployment does not exist."
          echo " > Installing Helm chart with image details..."
          envsubst < values.yaml | helm install ${{ vars.APP_NAME }} . --debug --namespace ${{ vars.EKS_NAMESPACE }} --create-namespace --values -
        fi

        #kubectl -n ${{ vars.EKS_NAMESPACE }} get pods -l app.kubernetes.io/name=${{ vars.APP_NAME }}
        #if kubectl -n ${{ vars.EKS_NAMESPACE }} get pods -l app.kubernetes.io/name=${{ vars.APP_NAME }} 2>&1 | grep -q "No resources found"; then
        #  
        #else
        #  
        #fi

        echo " > Verifying deployment..."
        kubectl -n ${{ vars.EKS_NAMESPACE }} get pods

        echo " > Getting last deployed pod ID"
        LAST_POD=$(kubectl -n ${{ vars.EKS_NAMESPACE }} get pods -l app.kubernetes.io/name=${{ vars.APP_NAME }} -o custom-columns=creationTimestamp:.metadata.creationTimestamp,PodName:.metadata.name --no-headers | sort -k1 | tail -n 1 | awk '{print $2}')
        echo "Last deployed pod $LAST_POD"
        echo " > Waiting for pod to be ready"
        OUT=$(kubectl -n ${{ vars.EKS_NAMESPACE }} wait --for=condition=ready pod/$LAST_POD --timeout=30s) || true
        echo "$OUT" | grep -q 'condition met' || {
          echo " > Getting NEW LAST deployed pod ID";
          LAST_POD_2=$(kubectl -n ${{ vars.EKS_NAMESPACE }} get pods -l app.kubernetes.io/name=${{ vars.APP_NAME }} -o custom-columns=creationTimestamp:.metadata.creationTimestamp,PodName:.metadata.name --no-headers | sort -k1 | tail -n 1 | awk '{print $2}');
          echo " > Getting pod logs $LAST_POD_2";
          echo $(kubectl -n ${{ vars.EKS_NAMESPACE }} logs $LAST_POD_2);
          echo "âŒ Pod $LAST_POD is not ready after 30 seconds";
        }
        kubectl -n ${{ vars.EKS_NAMESPACE }} get pods
        LAST_POD=$(kubectl -n ${{ vars.EKS_NAMESPACE }} get pods -l app.kubernetes.io/name=${{ vars.APP_NAME }} -o custom-columns=creationTimestamp:.metadata.creationTimestamp,PodName:.metadata.name --no-headers | sort -k1 | tail -n 1 | awk '{print $2}')
        echo " > Describing pod $LAST_POD"
        kubectl -n ${{ vars.EKS_NAMESPACE }} describe pod $LAST_POD
        POD_STATUS=$(kubectl -n ${{ vars.EKS_NAMESPACE }} get pod $LAST_POD --no-headers | awk '{print $3}')
        if [ "$POD_STATUS" != "Running" ]; then
          echo " > Getting pod logs";
          echo $(kubectl -n ${{ vars.EKS_NAMESPACE }} logs $LAST_POD);
          echo "âŒ Pod $LAST_POD is not running (status $POD_STATUS)";
          echo "âŒ DEPLOYED ERROR.";
          az logout
          exit 1;
        fi
        echo "ğŸ‘‰ğŸ» âœ… DEPLOYED SUCCESSFULLY to EKS cluster ${{ vars.EKS_CLUSTER_NAME }} in namespace ${{ vars.EKS_NAMESPACE }} using image $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        echo "ğŸ‘‰ğŸ» âœ…  Visit https://${{ vars.HOST_NAME }} to see your application"
